# Plano de Teste para Model de Produto

| Funcionalidade                   | Comportamento Esperado                                                                 | Verificações                                                      | Critérios de Aceite                                                                                           |
|----------------------------------|----------------------------------------------------------------------------------------|-------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| Cadastro válido de produto       | Um produto com todos os dados válidos deve ser salvo corretamente                      | Criar um produto com todos os campos preenchidos                 | O produto é salvo e os dados podem ser consultados com precisão                                              |
| Código duplicado                 | O sistema não deve permitir dois produtos com o mesmo código                           | Tentar cadastrar dois produtos com o mesmo código                | A operação falha com erro de chave duplicada referente ao campo `codigo`                                     |
| Nome duplicado                   | O sistema não deve permitir dois produtos com o mesmo nome                             | Tentar cadastrar dois produtos com o mesmo nome                  | A operação falha com erro de chave duplicada referente ao campo `nome`                                       |
| Isolamento entre testes          | Cada teste deve rodar com um banco limpo                                               | Verificar que `deleteMany` é chamado após cada teste             | Nenhum teste interfere no estado de outro, garantindo independência                                          |
| Conexão e desconexão do banco    | O banco em memória deve ser iniciado antes e desligado após os testes                 | Usar `beforeAll` para iniciar e `afterAll` para encerrar         | Os testes se conectam corretamente ao banco e liberam recursos no fim                                        |
| Índices do modelo                | Os índices devem ser criados corretamente antes da execução dos testes                 | Verificar que `createIndexes()` é chamado no modelo              | O Mongo cria os índices exigidos, como os de unicidade (`codigo`, `nome`)                                    |


# Plano de Teste para Controller Produto

| Funcionalidade                  | Comportamento Esperado                                                                 | Verificações                                                                 | Critérios de Aceite                                                                                  |
|---------------------------------|----------------------------------------------------------------------------------------|------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------|
| Listagem geral de produtos      | Deve retornar todos os produtos cadastrados                                            | Chamar `listar` sem `params` ou `query`                                     | A resposta deve conter status `200` e um array com todos os produtos                                  |
| Listagem por ID                 | Deve retornar um único produto quando passado o ID                                     | Chamar `listar` com `req.params.id`                                         | A resposta deve conter status `200` e o objeto do produto correspondente                              |
| Listagem por query              | Deve retornar o(s) produto(s) filtrado(s) por campo (ex: nome, categoria)               | Chamar `listar` com `req.query.nome` ou `req.query.categoria`               | A resposta deve conter status `200` e o(s) produto(s) filtrado(s)                                     |
| Cadastro de produto             | Deve permitir cadastrar um novo produto com dados válidos                              | Chamar `cadastrarProduto` com `req.body` preenchido                         | A resposta deve conter status `201`, um objeto com os dados e uma mensagem de sucesso                 |
| Atualização de produto          | Deve permitir atualizar os dados de um produto existente pelo ID                       | Chamar `updateProduto` com `req.params.id` e novos dados em `req.body`      | A resposta deve conter status `200`, os dados atualizados e uma mensagem de sucesso                   |
| Erro ao atualizar sem ID        | Não deve permitir atualizar um produto se o ID não for informado                       | Chamar `updateProduto` sem definir `req.params`                             | A função deve lançar um erro e não deve retornar status `200`                                         |
| Inicialização dos mocks         | A cada teste os mocks devem ser limpos e o controller reinicializado                   | Verificar uso de `jest.clearAllMocks()` e recriação de instâncias           | Cada teste deve ser isolado e não dependente de dados ou estado de outros                             |


# Plano de Teste para Service Produto

| Funcionalidade                       | Comportamento Esperado                                                                              | Verificações                                                                 | Critérios de Aceite                                                                                      |
|-------------------------------------|-------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| Listagem geral de produtos          | Deve retornar todos os produtos cadastrados                                                           | Chamar `listar` sem parâmetros                                               | A função retorna um array com todos os produtos                                                           |
| Listagem por ID                     | Deve retornar um produto específico baseado no ID                                                     | Chamar `listar` com `req.params.id`                                          | A função retorna o produto correspondente                                                                 |
| Listagem com filtros (query)        | Deve filtrar produtos com base em parâmetros (ex: nome, categoria)                                    | Chamar `listar` com `req.query`                                              | A função retorna apenas os produtos compatíveis com os filtros                                            |
| Cadastro válido                     | Deve cadastrar um novo produto se código e nome forem únicos                                           | Chamar `cadastrarProduto` com dados válidos                                  | O produto é cadastrado e retornado com um ID                                                              |
| Erro de código duplicado            | Deve lançar erro se o código já estiver em uso                                                         | Simular `buscarPorCodigo` retornando erro `CustomError`                      | A função deve lançar `CustomError` com mensagem de conflito de código                                     |
| Erro de nome duplicado              | Deve lançar erro se o nome já estiver em uso                                                           | Simular `buscarPorNome` retornando erro `CustomError`                        | A função deve lançar `CustomError` com mensagem de conflito de nome                                       |
| Atualização completa de produto     | Deve permitir atualizar todos os campos permitidos com dados válidos                                  | Chamar `updateProduto` com `req.params.id` e `req.body` completo             | A função deve retornar os dados atualizados corretamente                                                  |
| Atualização parcial de produto      | Deve permitir atualizar somente alguns campos de um produto                                           | Chamar `updateProduto` com ID e dados parciais                               | A função retorna os dados modificados preservando os anteriores                                           |
| Erro ao atualizar código duplicado  | Deve lançar erro se o novo código já estiver associado a outro produto                                | Simular `buscarPorCodigo` retornando erro                                    | A função lança `CustomError` com mensagem de conflito de código                                           |
| Erro ao atualizar nome já usado     | Deve lançar erro se o novo nome já estiver associado a outro produto                                  | Simular `buscarPorNome` retornando erro                                      | A função lança `CustomError` com mensagem de conflito de nome                                             |
| Atualizar quantidade em estoque     | Deve atualizar corretamente a quantidade em estoque do produto                                       | Chamar `atualizarEstoque` com ID e nova quantidade                           | A função retorna o produto com a quantidade atualizada                                                    |
| Erro ao atualizar estoque negativo  | Deve lançar erro ao tentar definir estoque como negativo                                             | Chamar `atualizarEstoque` com valor negativo                                 | A função lança `CustomError` com mensagem sobre estoque inválido                                          |
| Limpeza de mocks                    | Após cada teste os mocks devem ser limpos                                                             | Verificar uso de `jest.clearAllMocks()`                                      | Os testes são isolados e não compartilham estado                                                           |


# Plano de Teste para Repository Produto

| Funcionalidade                          | Comportamento Esperado                                                                 | Verificações                                                                          | Critérios de Aceite                                                                                         |
|----------------------------------------|----------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------|
| Buscar por ID                          | Deve retornar um produto existente a partir do ID                                      | Chamar `listar` com `req.params.id`                                                  | A função retorna o produto correspondente                                                                 |
| Não encontrar por ID                   | Deve retornar `null` se o produto com o ID não existir                                 | Chamar `listar` com um ID inexistente                                                | A função retorna `null`                                                                                    |
| Listagem paginada                      | Deve retornar todos os produtos com metadados de paginação                             | Chamar `listar` sem parâmetros                                                       | A função retorna array de produtos e dados como `totalDocs`, `page`, `limit`, etc.                         |
| Atualizar produto                      | Deve atualizar um produto existente com sucesso                                        | Chamar `updateProduto` com ID e dados válidos                                        | A função retorna o objeto atualizado                                                                       |
| Erro ao atualizar (código persistente) | Deve lançar erro se tentar atualizar para um código já existente                       | Simular `findByIdAndUpdate` retornando `null`                                        | A função lança `CustomError` com mensagem de "Recurso não encontrado"                                      |
| Cadastro de produto                    | Deve cadastrar um novo produto                                                         | Chamar `cadastrarProduto` com dados válidos                                          | A função retorna o objeto criado com sucesso                                                               |
| Verificação de código único            | Deve retornar `undefined` se não existir código duplicado                              | Chamar `buscarPorCodigo` com código inexistente                                      | A função resolve sem erro                                                                                  |
| Verificação de nome único              | Deve retornar `undefined` se não existir nome duplicado                                | Chamar `buscarPorNome` com nome inexistente                                          | A função resolve sem erro                                                                                  |
| Buscar por código                      | Deve retornar `undefined` se o código não estiver em uso                                | Chamar `buscarPorCodigo` com código inexistente                                      | A função resolve como `undefined`                                                                          |
| Buscar por ID (direto)                 | Deve retornar o produto existente a partir de um ID                                    | Chamar `buscarPorId`                                                                 | A função retorna o objeto do produto                                                                       |
| Erro ao buscar por código existente    | Deve lançar `CustomError` se o código já estiver em uso                                | Simular `findOne` retornando objeto                                                  | A função lança erro de conflito                                                                            |
| Erro ao buscar por nome existente      | Deve lançar `CustomError` se o nome já estiver em uso                                  | Simular `findOne` retornando objeto                                                  | A função lança erro de conflito                                                                            |
| Erro ao buscar por ID inexistente      | Deve lançar `CustomError` se o produto com o ID não existir                            | Simular `findById` retornando `null`                                                 | A função lança erro de recurso não encontrado                                                              |
| Atualizar quantidade em estoque        | Deve atualizar corretamente apenas o campo de quantidade                               | Chamar `atualizarEstoque` com ID e nova quantidade                                   | A função retorna o produto com a quantidade atualizada                                                     |
| Isolamento entre testes                | Cada teste deve rodar com dados limpos e mocks reiniciados                             | Verificar uso de `jest.clearAllMocks()`                                              | Nenhum teste interfere no outro                                                                            |


# Plano de Teste para FilterBuilder Produto

| Funcionalidade                  | Comportamento Esperado                                                                      | Verificações                                                             | Critérios de Aceite                                                                 |
|---------------------------------|---------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------------------|
| Filtro por nome                 | Deve adicionar uma condição de filtro pelo nome                                             | Chamar `comNome('Produto Teste')` seguido de `build()`                   | O resultado contém a chave `nome` com regex insensível a maiúsculas                 |
| Nome vazio ou indefinido        | Não deve adicionar filtro se o nome for `''` ou `undefined`                                | Chamar `comNome('')` e `comNome(undefined)`                              | O resultado **não** possui a chave `nome`                                           |
| Filtro por código               | Deve adicionar uma condição de filtro pelo código                                           | Chamar `comCodigo('ABC123')` seguido de `build()`                        | O resultado contém a chave `codigo` com regex insensível a maiúsculas               |
| Código vazio ou indefinido      | Não deve adicionar filtro se o código for `''` ou `undefined`                              | Chamar `comCodigo('')` e `comCodigo(undefined)`                          | O resultado **não** possui a chave `codigo`                                         |
| Filtro por descrição            | Deve adicionar uma condição de filtro pela descrição                                        | Chamar `comDescricao('Produto de teste')` seguido de `build()`           | O resultado contém a chave `descricao` com regex insensível a maiúsculas            |
| Descrição vazia ou indefinida   | Não deve adicionar filtro se a descrição for `''` ou `undefined`                           | Chamar `comDescricao('')` e `comDescricao(undefined)`                    | O resultado **não** possui a chave `descricao`                                      |
| Filtro por categoria            | Deve adicionar uma condição de filtro pela categoria                                        | Chamar `comCategoria('Eletrônicos')` seguido de `build()`                | O resultado contém a chave `categoria` com regex insensível a maiúsculas            |
| Categoria vazia ou indefinida   | Não deve adicionar filtro se a categoria for `''` ou `undefined`                           | Chamar `comCategoria('')` e `comCategoria(undefined)`                    | O resultado **não** possui a chave `categoria`                                      |
| Filtro por fabricante           | Deve adicionar uma condição de filtro pelo fabricante                                       | Chamar `comFabricante('Samsung')` seguido de `build()`                   | O resultado contém a chave `fabricante` com regex insensível a maiúsculas           |
| Fabricante vazio ou indefinido  | Não deve adicionar filtro se o fabricante for `''` ou `undefined`                          | Chamar `comFabricante('')` e `comFabricante(undefined)`                  | O resultado **não** possui a chave `fabricante`                                     |
| Filtro por preço mínimo         | Deve adicionar uma condição de filtro de preço maior ou igual                               | Chamar `comPrecoMinimo(10.5)` seguido de `build()`                       | O resultado contém `preco: { $gte: 10.5 }`                                          |
| Preço mínimo inválido           | Não deve adicionar filtro se o preço mínimo não for um número positivo                     | Chamar `comPrecoMinimo(-5)` e `comPrecoMinimo(undefined)`               | O resultado **não** possui a chave `preco.$gte`                                     |
| Filtro por preço máximo         | Deve adicionar uma condição de filtro de preço menor ou igual                               | Chamar `comPrecoMaximo(100)` seguido de `build()`                        | O resultado contém `preco: { $lte: 100 }`                                           |
| Preço máximo inválido           | Não deve adicionar filtro se o preço máximo não for um número positivo                     | Chamar `comPrecoMaximo(-10)` e `comPrecoMaximo(undefined)`              | O resultado **não** possui a chave `preco.$lte`                                     |
| Filtro por estoque mínimo       | Deve adicionar uma condição de filtro de estoque maior ou igual                             | Chamar `comEstoqueMinimo(5)` seguido de `build()`                        | O resultado contém `quantidade: { $gte: 5 }`                                        |
| Estoque mínimo inválido         | Não deve adicionar filtro se o estoque mínimo não for um número positivo                   | Chamar `comEstoqueMinimo(-2)` e `comEstoqueMinimo(undefined)`           | O resultado **não** possui a chave `quantidade.$gte`                                |
| Reset e isolamento              | Os filtros devem ser reinicializados entre os testes para não acumularem configurações      | Verificar uso de `beforeEach` e `jest.clearAllMocks()`                   | Cada chamada do builder é independente e não herda filtros anteriores               |


# Plano de Teste para Schema Produto

| Funcionalidade                     | Comportamento Esperado                                                                                     | Verificações                                                                       | Critérios de Aceite                                                                                     |
|------------------------------------|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| Validação completa (`parse`)       | Deve validar todos os campos com dados válidos                                                             | Usar `ProdutoSchema.parse()` com mock completo                                     | Todos os campos são aceitos sem exceções                                                                |
| Nome - formato inválido            | Deve lançar erro se nome contiver caracteres especiais inválidos                                           | Usar `.parseAsync({nome: "Nome@#!"})`                                             | Retorna erro de validação para formato incorreto                                                       |
| Nome - tipo incorreto              | Deve lançar erro se nome não for do tipo string                                                            | Usar `.parseAsync({nome: 123})`                                                   | Retorna erro dizendo que o nome deve ser string                                                        |
| Nome - campo vazio                 | Deve lançar erro se nome estiver vazio                                                                     | Usar `.parseAsync({nome: ""})`                                                    | Retorna erro de campo obrigatório                                                                      |
| Código - válido                    | Deve aceitar código alfanumérico válido                                                                    | Usar `.parse({codigo: "PRD123"})`                                                 | Retorna os dados normalmente                                                                           |
| Código - formato inválido          | Deve lançar erro para código com caracteres especiais                                                      | Usar `.parseAsync({codigo: "PRD@123"})`                                           | Retorna erro de formato de código                                                                      |
| Código - campo vazio               | Deve lançar erro se o campo de código estiver vazio                                                        | Usar `.parseAsync({codigo: ""})`                                                  | Retorna erro de campo obrigatório                                                                      |
| Código - tipo incorreto            | Deve lançar erro se código não for string                                                                  | Usar `.parseAsync({codigo: 123})`                                                 | Retorna erro de tipo                                                                                   |
| Descrição - válido                 | Deve aceitar descrição com comprimento adequado                                                            | Usar `.parse({descricao: "Descrição do produto de teste"})`                       | Retorna os dados normalmente                                                                           |
| Descrição - muito longa            | Deve lançar erro para descrição muito extensa                                                              | Usar `.parseAsync({descricao: "a".repeat(1001)})`                                | Retorna erro de tamanho máximo                                                                         |
| Descrição - tipo incorreto         | Deve lançar erro se descrição não for string                                                               | Usar `.parseAsync({descricao: 123})`                                              | Retorna erro de tipo                                                                                   |
| Preço - válido                     | Deve aceitar preço como número positivo                                                                    | Usar `.parse({preco: 10.99})`                                                     | Retorna os dados normalmente                                                                           |
| Preço - negativo                   | Deve lançar erro para preço negativo                                                                      | Usar `.parseAsync({preco: -10})`                                                  | Retorna erro de valor mínimo                                                                           |
| Preço - tipo incorreto             | Deve lançar erro se preço não for número                                                                   | Usar `.parseAsync({preco: "10.99"})`                                              | Retorna erro de tipo                                                                                   |
| Preço - valor zero                 | Deve lançar erro se preço for zero                                                                         | Usar `.parseAsync({preco: 0})`                                                    | Retorna erro de valor mínimo maior que zero                                                            |
| Quantidade - válida                | Deve aceitar quantidade como número inteiro não negativo                                                   | Usar `.parse({quantidade: 10})`                                                   | Retorna os dados normalmente                                                                           |
| Quantidade - negativa              | Deve lançar erro para quantidade negativa                                                                 | Usar `.parseAsync({quantidade: -1})`                                              | Retorna erro de valor mínimo                                                                           |
| Quantidade - tipo incorreto        | Deve lançar erro se quantidade não for número inteiro                                                      | Usar `.parseAsync({quantidade: "10"})`                                            | Retorna erro de tipo                                                                                   |
| Quantidade - decimal               | Deve lançar erro se quantidade for número decimal                                                          | Usar `.parseAsync({quantidade: 10.5})`                                            | Retorna erro informando que deve ser inteiro                                                           |
| Categoria - válida                 | Deve aceitar categoria com formato correto                                                                 | Usar `.parse({categoria: "Eletrônicos"})`                                         | Retorna os dados normalmente                                                                           |
| Categoria - formato inválido       | Deve lançar erro para categoria com caracteres especiais                                                  | Usar `.parseAsync({categoria: "Categoria@#!"})`                                   | Retorna erro de formato                                                                                |
| Categoria - tipo incorreto         | Deve lançar erro se categoria não for string                                                               | Usar `.parseAsync({categoria: 123})`                                              | Retorna erro de tipo                                                                                   |
| Fabricante - válido                | Deve aceitar nome de fabricante com formato correto                                                        | Usar `.parse({fabricante: "Samsung"})`                                            | Retorna os dados normalmente                                                                           |
| Fabricante - formato inválido      | Deve lançar erro para fabricante com caracteres especiais                                                 | Usar `.parseAsync({fabricante: "Fabricante@#!"})`                                | Retorna erro de formato                                                                                |
| Fabricante - tipo incorreto        | Deve lançar erro se fabricante não for string                                                             | Usar `.parseAsync({fabricante: 123})`                                             | Retorna erro de tipo                                                                                   |
| Imagem - válida                    | Deve aceitar URL de imagem válida                                                                          | Usar `.parse({imagemUrl: "https://exemplo.com/imagem.jpg"})`                      | Retorna os dados normalmente                                                                           |
| Imagem - URL inválida              | Deve lançar erro para URL de imagem com formato incorreto                                                 | Usar `.parseAsync({imagemUrl: "texto-invalido"})`                                | Retorna erro de URL inválida                                                                           |
| Imagem - tipo incorreto            | Deve lançar erro se URL de imagem não for string                                                          | Usar `.parseAsync({imagemUrl: 123})`                                              | Retorna erro de tipo                                                                                   |
| Data de validade - válida          | Deve aceitar data de validade no futuro                                                                   | Usar `.parse({dataValidade: "2026-01-01"})`                                       | Retorna os dados normalmente                                                                           |
| Data validade - no passado         | Deve lançar erro para data de validade no passado                                                         | Usar `.parseAsync({dataValidade: "2020-01-01"})`                                 | Retorna erro de data inválida                                                                          |
| Data validade - formato inválido   | Deve lançar erro para formato de data incorreto                                                           | Usar `.parseAsync({dataValidade: "01/01/2026"})`                                 | Retorna erro de formato de data                                                                        |
| Data validade - tipo incorreto     | Deve lançar erro se data não for string em formato ISO                                                     | Usar `.parseAsync({dataValidade: 123})`                                           | Retorna erro de tipo                                                                                   |


# Plano de Teste para QuerySchema Produto

| Funcionalidade               | Comportamento Esperado                                                                          | Verificações                                                                    | Critérios de Aceite                                                                                 |
|------------------------------|-------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| Nome - válido                | Deve aceitar nome não vazio e sem apenas espaços                                                | Usar `.parse({ nome: "Produto" })`                                              | Retorna objeto com o nome                                                                           |
| Nome - inválido              | Deve lançar erro se nome for apenas espaços                                                     | Usar `.parseAsync({ nome: " " })`                                               | Retorna mensagem "Nome não pode ser vazio ou apenas espaços"                                       |
| Código - válido              | Deve aceitar código alfanumérico                                                                | Usar `.parse({ codigo: "PRD123" })`                                             | Retorna objeto com o código                                                                         |
| Código - inválido            | Deve lançar erro para código com caracteres especiais                                           | Usar `.parseAsync({ codigo: "PRD@123" })`                                       | Retorna mensagem "Formato de código inválido"                                                       |
| Categoria - válida           | Deve aceitar categoria com formato válido                                                       | Usar `.parse({ categoria: "Eletrônicos" })`                                     | Retorna objeto com a categoria                                                                      |
| Categoria - inválida         | Deve lançar erro para categoria com caracteres especiais                                        | Usar `.parseAsync({ categoria: "Categoria@#!" })`                               | Retorna mensagem "Formato de categoria inválido"                                                    |
| Fabricante - válido          | Deve aceitar fabricante com formato válido                                                      | Usar `.parse({ fabricante: "Samsung" })`                                        | Retorna objeto com o fabricante                                                                     |
| Fabricante - inválido        | Deve lançar erro para fabricante com caracteres especiais                                       | Usar `.parseAsync({ fabricante: "Fabricante@#!" })`                             | Retorna mensagem "Formato de fabricante inválido"                                                   |
| Preço mínimo - válido        | Deve aceitar preço mínimo como número positivo                                                  | Usar `.parse({ precoMinimo: "10.5" })`                                          | Retorna `{ precoMinimo: 10.5 }`                                                                     |
| Preço mínimo - negativo      | Deve lançar erro para preço mínimo negativo                                                     | Usar `.parseAsync({ precoMinimo: "-10" })`                                      | Retorna mensagem "Preço mínimo deve ser maior ou igual a zero"                                      |
| Preço mínimo - não numérico  | Deve lançar erro para preço mínimo não numérico                                                 | Usar `.parseAsync({ precoMinimo: "abc" })`                                      | Retorna mensagem "Preço mínimo deve ser um número"                                                  |
| Preço máximo - válido        | Deve aceitar preço máximo como número positivo                                                  | Usar `.parse({ precoMaximo: "100" })`                                           | Retorna `{ precoMaximo: 100 }`                                                                      |
| Preço máximo - negativo      | Deve lançar erro para preço máximo negativo                                                     | Usar `.parseAsync({ precoMaximo: "-100" })`                                     | Retorna mensagem "Preço máximo deve ser maior que zero"                                             |
| Preço máximo - não numérico  | Deve lançar erro para preço máximo não numérico                                                | Usar `.parseAsync({ precoMaximo: "abc" })`                                      | Retorna mensagem "Preço máximo deve ser um número"                                                  |
| Estoque mínimo - válido      | Deve aceitar estoque mínimo como número inteiro não negativo                                    | Usar `.parse({ estoqueMinimo: "5" })`                                           | Retorna `{ estoqueMinimo: 5 }`                                                                      |
| Estoque mínimo - negativo    | Deve lançar erro para estoque mínimo negativo                                                   | Usar `.parseAsync({ estoqueMinimo: "-5" })`                                     | Retorna mensagem "Estoque mínimo não pode ser negativo"                                             |
| Estoque mínimo - decimal     | Deve lançar erro para estoque mínimo como número decimal                                        | Usar `.parseAsync({ estoqueMinimo: "5.5" })`                                    | Retorna mensagem "Estoque mínimo deve ser um número inteiro"                                        |
| Página - válida              | Deve converter valor string numérico em inteiro                                                 | Usar `.parse({ page: "1" })`                                                    | Retorna `{ page: 1 }`                                                                               |
| Página - inválida            | Deve lançar erro para valores não numéricos ou negativos                                        | Usar `.parseAsync({ page: "abc" })`                                             | Retorna mensagem "Page deve ser um número inteiro maior que 0"                                     |
| Página - valor padrão        | Deve usar `1` como valor padrão se não for fornecido                                            | Usar `.parse({ page: "" })`                                                     | Retorna `{ page: 1 }`                                                                               |
| Limite - válido              | Deve converter string numérica em inteiro dentro do intervalo permitido                        | Usar `.parse({ limite: "10" })`                                                 | Retorna `{ limite: 10 }`                                                                            |
| Limite - maior que 100       | Deve lançar erro se valor for superior a 100                                                    | Usar `.parseAsync({ limite: "101" })`                                           | Retorna mensagem "Limite deve ser um número inteiro entre 1 e 100"                                 |
| Limite - não numérico        | Deve lançar erro se valor não for um número                                                     | Usar `.parseAsync({ limite: "abc" })`                                           | Retorna mensagem "Limite deve ser um número inteiro entre 1 e 100"                                 |
| Limite - valor padrão        | Deve usar `10` como valor padrão se `limite` não for fornecido                                  | Usar `.parse({})`                                                               | Retorna `{ limite: 10 }`                                                                            |